<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brachistochrone Problem Visualization (Dark Mode)</title>
    <!-- Plotly.js CDN -->
    <script src="https://cdn.plot.ly/plotly-2.29.1.min.js" charset="utf-8"></script>
    <style>
        body {
            font-family: sans-serif;
            margin: 0; /* Remove default margin */
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #222; /* Dark background */
            color: #e0e0e0; /* Light text */
        }
        h1 {
            text-align: center;
            color: #e0e0e0; /* Light text for heading */
        }
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #333; /* Slightly lighter dark for controls background */
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: 10px 20px;
            align-items: center;
            max-width: 550px;
            width: 90%;
        }
        .controls label {
            text-align: right;
            color: #ccc; /* Lighter grey for labels */
        }
        .controls input[type="range"] {
            width: 100%;
            min-width: 150px;
            /* Basic cross-browser dark mode for sliders */
            accent-color: #007bff; /* Color for the thumb and active track part */
        }
        .controls input[type="range"]::-webkit-slider-runnable-track {
            background: #555; /* Darker track for WebKit */
        }
        .controls input[type="range"]::-moz-range-track {
            background: #555; /* Darker track for Firefox */
        }
        .controls span {
            color: #e0e0e0; /* Light text for slider values */
        }

        #plotDiv {
            width: 90vw;
            max-width: 800px;
            height: 60vh;
            max-height: 600px;
            border: 1px solid #555; /* Lighter border for plot area */
            border-radius: 4px;
        }
        #errorMessage {
            color: #ff6b6b; /* Light red for error messages */
            margin-top: 15px;
            text-align: center;
            min-height: 1.2em;
            font-weight: bold;
        }
        a {
            color: #6cb2eb; /* Lighter blue for links if any were added */
        }
        a:hover {
            color: #8ec9f2;
        }
    </style>
</head>
<body>

    <h1>Brachistochrone Curve</h1>

    <div class="controls">
        <label for="yStartSlider">Start Height (y₁):</label>
        <input type="range" id="yStartSlider" min="0" max="10" value="5" step="0.1">
        <span id="yStartValue">5.0</span>

        <label for="yEndSlider">End Height (y₂):</label>
        <input type="range" id="yEndSlider" min="0" max="10" value="1" step="0.1">
        <span id="yEndValue">1.0</span>

        <label for="xLengthSlider">Horizontal Span (X):</label>
        <input type="range" id="xLengthSlider" min="0" max="10" value="5" step="0.1">
        <span id="xLengthValue">5.0</span>
    </div>

    <div id="plotDiv"></div>
    <div id="errorMessage"></div>

    <script>
        const yStartSlider = document.getElementById('yStartSlider');
        const yEndSlider = document.getElementById('yEndSlider');
        const xLengthSlider = document.getElementById('xLengthSlider');

        const yStartValueSpan = document.getElementById('yStartValue');
        const yEndValueSpan = document.getElementById('yEndValue');
        const xLengthValueSpan = document.getElementById('xLengthValue');

        const plotDiv = document.getElementById('plotDiv');
        const errorMessageDiv = document.getElementById('errorMessage');

        // Bisection method (same as before)
        function bisection(func, a, b, tolerance = 1e-7, maxIterations = 100) {
            let fa = func(a);
            let fb = func(b);
            if (Math.abs(fa) < tolerance) return a;
            if (Math.abs(fb) < tolerance) return b;
            if (fa * fb >= 0) {
                console.warn("Bisection: f(a) and f(b) must have opposite signs.", {a, fa, b, fb});
                return NaN;
            }
            let c = a;
            for (let i = 0; i < maxIterations; i++) {
                c = (a + b) / 2;
                const fc = func(c);
                if (Math.abs(fc) < tolerance || (b - a) / 2 < tolerance) return c;
                if (fa * fc < 0) { b = c; fb = fc; }
                else { a = c; fa = fc; }
            }
            console.warn("Bisection: Max iterations reached.");
            return c;
        }

        // solveForThetaFinal (same as before)
        function solveForThetaFinal(deltaX, deltaY) {
            if (deltaX < 1e-9 && deltaX > -1e-9) return 0;
            if (deltaY < 1e-9 && deltaY > -1e-9) return 2 * Math.PI;
            const ratio = deltaX / deltaY;
            const funcToSolve = (theta) => {
                const oneMinusCosTheta = 1.0 - Math.cos(theta);
                if (Math.abs(oneMinusCosTheta) < 1e-9) {
                    if (theta < 1e-6) return theta / 3.0 - ratio;
                    return (theta - Math.sin(theta)) / (oneMinusCosTheta + Math.sign(oneMinusCosTheta)*1e-12) - ratio;
                }
                return (theta - Math.sin(theta)) / oneMinusCosTheta - ratio;
            };
            let lowerBound = 1e-7;
            let upperBound = 2 * Math.PI - 1e-7;
            const thetaF = bisection(funcToSolve, lowerBound, upperBound);
            if (isNaN(thetaF)) {
                if (ratio > 0 && ratio < 0.01) {
                    console.warn("Bisection failed, falling back to Taylor approx for small ratio.");
                    return ratio * 3.0;
                }
            }
            return thetaF;
        }

        function updatePlot() {
            const yStart = parseFloat(yStartSlider.value);
            const yEnd = parseFloat(yEndSlider.value);
            const xLength = parseFloat(xLengthSlider.value);

            yStartValueSpan.textContent = yStart.toFixed(1);
            yEndValueSpan.textContent = yEnd.toFixed(1);
            xLengthValueSpan.textContent = xLength.toFixed(1);
            errorMessageDiv.textContent = "";

            if (yEnd > yStart + 1e-6) {
                errorMessageDiv.textContent = "End height (y₂) must be at or below start height (y₁).";
                Plotly.react(plotDiv, [], {
                    title: 'Brachistochrone Curve (Invalid Parameters)',
                    template: 'plotly_dark', // Apply dark theme to error plot too
                    xaxis: { title: 'Horizontal Distance (x)', range: [0, Math.max(1, xLength)], zeroline: false },
                    yaxis: { title: 'Height (y)', range: [Math.min(0,yStart,yEnd)-1, Math.max(1,yStart,yEnd)+1], scaleanchor: "x", scaleratio: 1, zeroline: false },
                    margin: { l: 60, r: 20, b: 50, t: 50, pad: 4 }
                });
                return;
            }

            const P1 = { x: 0, y: yStart };
            const P2 = { x: xLength, y: yEnd };
            const traces = [];

            traces.push({
                x: [P1.x, P2.x], y: [P1.y, P2.y], mode: 'lines',
                line: { dash: 'dash', color: '#ff6347' }, name: 'Straight Line' // Tomato red
            });

            const deltaX = xLength;
            const deltaY = yStart - yEnd;
            let R, thetaF;
            let xCycloid = [], yCycloid = [];

            if (deltaX < 1e-9 && deltaY < 1e-9) {
                xCycloid = [P1.x]; yCycloid = [P1.y]; R = 0;
            } else if (deltaX < 1e-9) {
                xCycloid = [P1.x, P2.x]; yCycloid = [P1.y, P2.y]; R = Infinity;
            } else if (deltaY < 1e-9) {
                thetaF = 2 * Math.PI;
                R = deltaX / (2 * Math.PI);
                if (R > 0) {
                    for (let i = 0; i <= 100; i++) {
                        const theta = (i / 100) * thetaF;
                        xCycloid.push(R * (theta - Math.sin(theta)));
                        yCycloid.push(yStart - R * (1 - Math.cos(theta)));
                    }
                } else { xCycloid = [P1.x]; yCycloid = [P1.y]; }
            } else {
                thetaF = solveForThetaFinal(deltaX, deltaY);
                if (isNaN(thetaF) || thetaF < 1e-7 || thetaF > 2 * Math.PI - 1e-7) {
                    if (deltaX / deltaY < 0.01 && deltaX / deltaY >= 0 && (isNaN(thetaF) || thetaF < 1e-7) ) {
                        errorMessageDiv.textContent = "Approximating as vertical drop (bisection difficulty).";
                        xCycloid = [P1.x, P2.x]; yCycloid = [P1.y, P2.y];
                    } else if (isNaN(thetaF)) {
                        errorMessageDiv.textContent = `Solver failed for ratio ${(deltaX/deltaY).toFixed(3)}. Try adjusting.`;
                    } else {
                        errorMessageDiv.textContent = `Calculated theta_f (${thetaF.toFixed(3)}) is out of expected range.`;
                    }
                    R = NaN;
                } else {
                    R = deltaY / (1 - Math.cos(thetaF));
                }

                if (R > 0 && !isNaN(R) && isFinite(R) && !isNaN(thetaF)) {
                    for (let i = 0; i <= 100; i++) {
                        const theta = (i / 100) * thetaF;
                        xCycloid.push(R * (theta - Math.sin(theta)));
                        yCycloid.push(yStart - R * (1 - Math.cos(theta)));
                    }
                } else if (!errorMessageDiv.textContent) {
                     errorMessageDiv.textContent = `Invalid R (${R ? R.toFixed(2) : R}) or theta_f (${thetaF ? thetaF.toFixed(3) : thetaF}).`;
                }
            }

            if (xCycloid.length > 0) {
                traces.push({
                    x: xCycloid, y: yCycloid, mode: 'lines',
                    line: { color: '#1f77b4', width: 2.5 }, name: 'Brachistochrone' // Plotly default blue, good contrast
                });
            }

            let xGenCircle = [], yGenCircle = [];
            if (R > 0 && R < Infinity && xCycloid.length > 1 && deltaX > 1e-9 && deltaY > 1e-9 && !isNaN(thetaF) && thetaF > 1e-7 && thetaF < (2*Math.PI - 1e-7) ) {
                const circleCenterX = R * thetaF;
                const circleCenterY = yStart - R;
                const N_circle_pts = 50;
                for (let i = 0; i <= N_circle_pts; i++) {
                    const angle = (i / N_circle_pts) * 2 * Math.PI;
                    xGenCircle.push(circleCenterX + R * Math.cos(angle));
                    yGenCircle.push(circleCenterY + R * Math.sin(angle));
                }
                traces.push({
                    x: xGenCircle, y: yGenCircle, mode: 'lines',
                    line: { color: '#7f7f7f', dash: 'dot', width: 1 }, name: 'Generating Circle' // Plotly default grey
                });
            }

            traces.push({
                x: [P1.x, P2.x], y: [P1.y, P2.y], mode: 'markers',
                marker: { color: '#fff', size: 8, line: {color: '#555', width:1} }, // White markers with dark outline
                name: 'Start/End Points'
            });

            let allX = [P1.x, P2.x, ...xCycloid, ...xGenCircle].filter(v => isFinite(v));
            let allY = [P1.y, P2.y, ...yCycloid, ...yGenCircle].filter(v => isFinite(v));
            let minX = 0, maxX = Math.max(1, xLength), minY = 0, maxY = Math.max(1, yStart, yEnd);
            if (allX.length > 0) { minX = Math.min(...allX); maxX = Math.max(...allX); }
            if (allY.length > 0) { minY = Math.min(...allY); maxY = Math.max(...allY); }
            const paddingX = Math.max((maxX - minX) * 0.1, 0.5);
            const paddingY = Math.max((maxY - minY) * 0.1, 0.5);

            const layout = {
                title: 'Brachistochrone Curve',
                template: 'plotly_dark', // KEY CHANGE for Plotly dark theme
                xaxis: { range: [minX - paddingX, maxX + paddingX], zeroline: false },
                yaxis: { range: [minY - paddingY, maxY + paddingY], scaleanchor: "x", scaleratio: 1, zeroline: false },
                legend: {
                    x: 0.05, y: 0.95,
                    // bgcolor: 'rgba(51,51,51,0.7)', // Darker legend background if needed
                    // bordercolor: '#777',
                    // font: { color: '#e0e0e0' } // Already handled by template: 'plotly_dark'
                },
                margin: { l: 60, r: 20, b: 50, t: 50, pad: 4 }
            };

            Plotly.react(plotDiv, traces, layout);
        }

        yStartSlider.addEventListener('input', updatePlot);
        yEndSlider.addEventListener('input', updatePlot);
        xLengthSlider.addEventListener('input', updatePlot);
        updatePlot();
    </script>

</body>
</html>
